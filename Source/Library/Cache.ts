///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
'use strict'; /// Strict Syntax //////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import $config from '../Common/Configuration'; /// Configuration Settings ////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import $utility from '../Common/Utility'; /// Utility Module /////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import * as $path from 'path'; /// Path Module ///////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import $crypto from './Cryptography'; /// Cryptography Module ////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
export default class LibraryCache { /// LibraryCache Class Definition //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/// Public Static Methods ////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	/**
	 * This method checks to see whether or not a cache file exists
	 * @async
	 * @name LibraryCache.exists()
	 * @param {string} $name
	 * @public
	 * @returns {Promise<boolean>}
	 * @static
	 */
	public static async exists($name: string): Promise<boolean> {
		// Define our file name
		let $fileName = $path.join($config.system.cache.directory, $config.system.cache.prefix.concat($name));
		// Try to stat the file
		try {
			// Stat the file
			await $utility.fsStat($fileName);
			// We're done, the file exists
			return true;
		} catch ($error) {
			// We're done, the file doesn't exist
			return false;
		}
	}

	/**
	 * This method reads a cached file from the filesystem
	 * @async
	 * @name LibraryCache.read()
	 * @param {string} $name
	 * @public
	 * @returns {Promise<string>}
	 * @static
	 */
	public static async read($name: string): Promise<string> {
		// Define our file name
		let $fileName = $path.join($config.system.cache.directory, $config.system.cache.prefix.concat($name));
		// Read the file
		let $cachedJsonData: string = await $utility.fsReadFile($fileName).toString();
		// Decode the data
		let $cachedData: {data:string, meta: {timeStamp: number, encrypted: boolean}, ttl: number} = JSON.parse($cachedJsonData.toString());
		// Check the timestamp
		if (((new Date).getTime() - $cachedData.meta.timeStamp) >= $config.system.cache.ttl) {
			// Define our error
			let $error = new Error('Cache Expired');
			// Set the status into the error
			$error.name = 'TUXCACHEEXPIRED';
			// We're done, throw the error
			throw $error;
		}
		// We're done, return the cached data
		return ($cachedData.meta.encrypted ? $crypto.staticKeyDecrypt($cachedData.data) : $cachedData.data);
	}

	/**
	 * This method a cache file to the filesystem
	 * @async
	 * @name LibraryCache.write()
	 * @param {string} $name
	 * @param {string} $data
	 * @param {boolean, optional} $encrypt
	 * @public
	 * @returns {Promise<{data: string, meta: {timeStamp: number, encrypted: boolean}, ttl: number}>}
	 * @static
	 */
	public static async write($name: string, $data: string, $encrypt?: boolean): Promise<{data: string, meta: {timeStamp: number, encrypted: boolean}, ttl: number}> {
		// Check for a provided encrypt flag
		if ($encrypt === undefined) {
			// Reset the encrypt flag
			$encrypt = $config.system.cache.encrypt;
		}
		// Define our file name
		let $fileName = $path.join($config.system.cache.directory, $config.system.cache.prefix.concat($name));
		// Define our cache object
		let $cachedData: {data: string, meta: {timeStamp: number, encrypted: boolean}, ttl: number} = {
			// Set the data into the cache object
			data: ($encrypt ? $crypto.staticKeyEncrypt($data) : $data),
			// Define the meta data for the cached file
			meta: {
				// Set the encrypted flag
				encrypted: $encrypt,
				// Set the creation timestamp
				timeStamp: Date.now()
			},
			// Set the time-to-live
			ttl: $config.system.cache.ttl
		};
		// Write the file to the filesystem
		await $utility.fsWriteFile($fileName, JSON.stringify($cachedData));
		// We're done, return the written data
		return $cachedData;
	}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}; /// End LibraryCache Class Definition /////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
